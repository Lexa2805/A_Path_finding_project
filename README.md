ðŸ¤– Interactive Path Planning Visualizer
This is a Python desktop application built with Tkinter that demonstrates and visually compares two fundamental space decomposition techniques for robot path planning:

Uniform Grid (Homogeneous Decomposition)

Quadtree (Adaptive Decomposition)

Users can interactively create maps with obstacles, choose their preferred decomposition method, and visualize the optimal path found by the A* (A-star) algorithm.

![Demo GIF showing map editing and path finding] (Suggestion: Replace this line with a GIF or screenshot of your application in action!)

ðŸš€ Features
Interactive Map Editor:

Click to place Start (green) and Goal (red) points.

Add complex obstacles: Rectangles, Circles, and Triangles.

Delete any object with a single click.

Instantly Generate a Random Map to test complex scenarios.

Two Decomposition Methods:

Choose between the simple Uniform Grid or the efficient Quadtree method at startup.

Set the Resolution (for Grid) or Max Depth (for Quadtree) to see how it affects performance and path quality.

A* Pathfinding:

Implements the A* algorithm to find the shortest path on the graph generated by the chosen method.

Visualizes the final path as a clear blue line.

Multithreaded & Responsive:

All heavy computations (graph generation and A* search) run on a separate worker thread.

This prevents the GUI from freezing ("Not Responding") on complex calculations, providing a smooth user experience.

ðŸ› ï¸ Technologies Used
Python 3

Tkinter: For the entire graphical user interface, control panel, and map canvas.

threading & queue: To manage background calculations and prevent the UI from blocking.

heapq: For the efficient priority queue required by the A* algorithm.

ðŸƒ How to Run
No external libraries are required (Tkinter, threading, and heapq are part of the Python standard library).

Clone the repository:

Bash

git clone https://github.com/your-username/your-repository-name.git
cd your-repository-name
Run the script:

Bash

python path_planner.py 
(Replace path_planner.py with the name of your Python file)

How to Use:

A setup window will first ask you to choose your Method (Grid/Quadtree) and its Parameter (Resolution/Depth).

The main editor will open. Use the "Tools" panel on the left to design your map.

Click the "FIND PATH" button to start the calculation and see the result.

ðŸ§  How It Works
This project turns a continuous 2D map into a discrete graph, which can then be solved by a search algorithm.

1. Uniform Grid
This is the simplest approach.

The map is divided into a fixed grid (e.g., 30x30).

Each cell is classified as FREE or OCCUPIED (if it intersects any obstacle).

A graph is built where each FREE cell is a node, connected to its adjacent FREE neighbors.

A* runs on this graph.

Downside: Very inefficient in large, open spaces, as it creates thousands of unnecessary nodes.

2. Quadtree
This is a much more efficient, adaptive approach.

The map starts as a single node (the root).

The node is checked:

If FREE: It becomes a green leaf node.

If OCCUPIED (and at max depth): It becomes a red leaf node.

If MIXED: It is recursively subdivided into four smaller child nodes (NW, NE, SW, SE).

This process repeats until the max depth is reached or all nodes are pure (fully FREE or OCCUPIED).

The graph is built by connecting the centers of adjacent FREE leaf nodes.

Advantage: Far fewer nodes are created. The computational effort is focused only where it's neededâ€”around the obstacle edges.

3. The "Not Responding" Problem (and Solution)
On deep Quadtrees (e.g., depth > 7), building the graph can take several seconds. Since Tkinter runs in a single thread, this calculation would normally freeze the entire application.

Solution: Multithreading

When "FIND PATH" is clicked, the UI is disabled, and a "Calculating..." label appears.

A new worker thread is started to run the _threaded_find_path function.

The main UI thread remains responsive and free.

The worker thread performs all the heavy work and, when finished, places the result (the path, decomposition data, and any errors) into a queue.

The UI thread polls this queue (using root.after()). When it finds the result, it retrieves it, re-enables the UI, and draws the final path on the canvas.
